import random
arr = [4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5,4,2,1,3,5]
# arr = arr[:100]
def quick(start, end): # 左闭右开区间
        # print(arr[start:end], start, end)
        if end <= start:
            return 

        k = arr[start] # base 元素
        
        # 左闭右闭区间
        left = start + 1
        right = end - 1
        
        while left <= right:
            while  left < end and arr[left] <= k:
                left += 1

            while right >=0 and arr[right] > k:
                right -= 1

            if left > right:
                break
            
            arr[left], arr[right] = arr[right], arr[left]
  

        arr[start], arr[right] = arr[right], arr[start]

        quick(start, right) 
        quick(left, end)

def quick(left, right): # 左闭右开
            if right <= left:
                return
            k = arr[left]
            l = left + 1
            r = right - 1
            # 搜索区间为左闭右闭
            while l <= r:
                
                while l < right and arr[l] < k:
                    l += 1
                while r >= 0 and arr[r] > k:
                    r -= 1
                if l >= r:
                    break
                
                arr[l], arr[r] = arr[r], arr[l] # 交换之后需要 l， r 移动，不然在面对 arr[l] == arr[r] == k时，会陷入死循环
                l += 1
                r -= 1

            arr[left], arr[r] = arr[r], arr[left]

            quick(left, r)
            quick(l, right)

quick(0, len(arr))
# print(arr)

# 快排 找寻 第 k 小的元素
def quick_select(left, right, k): # 闭区间
    
    idx = random.randint(left, right)
    t = nums[idx]
    # 将 t 交换到最后一个位置
    nums[idx], nums[right] = nums[right], nums[idx]

    l, r = left, right - 1
    while l <= r:
        while l <= r and nums[l] < t:
            l += 1
        
        while l <= r and nums[r] > t:
            r -= 1
        
        if l>=r: break
        nums[l], nums[r] = nums[r], nums[l]
        l, r = l+1, r-1

    # nums[l] 可能大于等于 t
    nums[l], nums[right] = nums[right], nums[l]
    # 查看区间[left...l]是否有k个元素
    if l - left + 1 == k:
        return t
    elif l - left + 1 > k:
        # 在[left, l-1/r] 中寻找 k 个元素
        return quick_select(left, l-1, k)
    else:
        # 在[l+1, right] 找寻 k-(l-left+1) 个元素
        return quick_select(l+1, right, k-(l-left+1))
nums = list([1,2,3])

print(quick_select(0, len(nums)-1, (len(nums)+1)//2+1))


class Solution:
    def containsNearbyAlmostDuplicate(self, nums, k: int, t: int) -> bool:
        from functools import cmp_to_key
        n = len(nums)
        res = [[] for i in range(n)]
        for i in range(n):
            res[i].extend(nums[max(0, i-k):min(n, k+i+1)])
            a = min(res[i], key=cmp_to_key(lambda x, y: abs(x-y)))
            print(res[i], a)
            if a <= t:
                return True
        
        return False

# print(Solution().containsNearbyAlmostDuplicate([1,2,3,1], 3, 0))


# 并查集
class Ufoid:
    def __init__(self, n):
        self.roots = list(range(n))
        self.count = n
    
    def find(self, a):
        while a != self.roots[a]:
            item = self.roots[a]
            self.roots[a]  = self.roots[item] # 压缩路径
            a = self.roots[a]
        return a
    
    def connect(self, a, b):
        return find(a) == find(b)
    
    def union(self, a, b):
        root_a, root_b = self.find(a), self.find(b)
        if root_a == root_b:
            return
        elif root_a <= root_b:
            self.roots[root_b] = root_a
        else:
            self.roots[root_a] = root_b
        
        self.count -= 1


num = [1, 2, 10, 1, 5, 10, 3, 3, 7, 2, 14, 14, 7, 7, 2, 6, 0, 1, 9, 2, 2, 3, 5, 4, 1, 5, 4, 6, 1, 14, 0, 6, 
5, 10, 1, 4, 6, 0, 6, 14]
n = len(num)
memory = {}
def dfs(l, r, h):
    if not h:
        return 0
    if memory.get((l, r)):
        return memory[(l, r)]
    hl = num[l-1] if l >0 else 0
    hr = num[r+1] if r<n-1 else 0
    
    left = right = 0
    if  hr:
        right = dfs( l, r+1, min(h, hr))
    if hl:
        left = dfs( l-1, r, min(hl, h))

    ans = max(left, right, h*(r-l+1))
    memory[(l, r)] = ans
    return ans

# for i in range(n):
#     i = 16
#     print(i, dfs(i,i, num[i]))


# 素数删表法
def prime(n):
    for i in range(2, int(n**.5)+1):
        if n % i:
            return False
    return True

def prime_table(n):
    ans = [True]*(n+1)
    for x in range(2, int(n**.5+1)):
        if prime(x):
            for j in range(x**2, n, x):
                ans[x] = False # 素数的倍数，不是素数
    
    # 返回素数的个数
    return sum(ans[2:])