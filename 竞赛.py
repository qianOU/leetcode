class Solution:
    # BFS
    def countPaths(self, n: int, roads) -> int:
        base = 10**9 + 7
        time = [float('inf')]*n
        count = [0]*n
        count[0] = 1
        time[0] = 0

        # 邻接表
        adj = [[] for i in range(n)]
        for i, j, c in roads:
            adj[i].append((j, c))
            adj[j].append((i, c))

        from collections import deque
        q = deque([(0, 0)])
        while q:
            cur, cost = q.popleft()
            if cost > time[cur]: continue
            for nxt, c in adj[cur]:
                if time[nxt] >= c + time[cur]:
                    if time[nxt] == c + time[cur]:
                        count[nxt] += 1
                        count[nxt] %= base
                    else: 
                        count[nxt] = 1
                    time[nxt] = c + time[cur]
                    q.append((nxt, c + time[cur]))

        return count[n-1], time[n-1]



print(Solution().countPaths(
19,
[[1,0,7714],[2,1,6248],[2,0,13962],[3,1,14818],[3,0,22532],[3,2,8570],[3,4,9230],[5,4,1241],[5,0,33003],[5,2,19041],[5,1,25289],[5,3,10471],[1,6,33307],[4,6,9259],[3,7,20212],[5,7,9741],[6,7,1723],[4,7,10982],[7,0,42744],[8,4,12772],[8,6,3513],[8,0,44534],[8,2,30572],[1,8,36820],[8,7,1790],[8,3,22002],[9,6,13145],[9,5,21163],[8,9,9632],[9,4,22404],[9,7,11422],[9,1,46452],[9,2,40204],[10,8,6014],[10,4,18786],[9,11,3472],[11,7,14894],[6,11,16617],[4,11,25876],[0,11,57638],[11,2,43676],[11,5,24635],[2,12,50515],[3,12,41945],[12,6,23456],[12,8,19943],[10,12,13929],[12,1,56763],[12,0,64477],[12,11,6839],[5,12,31474],[12,4,32715],[12,13,1401],[13,10,15330],[8,13,21344],[4,13,34116],[13,1,58164],[3,13,43346],[9,13,11712],[13,0,65878],[13,11,8240],[13,7,23134],[11,14,10467],[13,14,2227],[14,12,3628],[14,1,60391],[14,5,35102],[10,14,17557],[14,4,36343],[14,0,68105],[14,7,25361],[8,14,23571],[6,14,27084],[14,3,45573],[14,2,54143],[14,9,13939],[15,6,35506],[7,15,33783],[15,14,8422],[15,5,43524],[16,7,4344],[16,1,39374],[0,16,47088],[8,16,2554],[0,17,77829],[17,4,46067],[8,17,33295],[17,6,36808],[17,11,20191],[17,10,27281],[17,1,70115],[16,17,30741],[14,17,9724],[15,17,1302],[7,17,35085],[18,3,57742],[18,12,15797],[18,7,37530],[18,15,3747],[14,18,12169],[18,5,47271],[18,9,26108]]
))

# class Solution:
#     def numberOfCombinations(self, num: str) -> int:
#         from functools import lru_cache
#         base = 10**9 + 7
#         n = len(num)
        
#         @lru_cache(None)
#         def dfs(s, last):
#             if s > n: return 0
#             elif s == n:
#                 return 1
#             if num[s] == '0': return 0
#             length = s - last
#             ans = 0
#             if last < 0 or  num[last:s] <= num[s:s+length]:
#                 ans += dfs(s+length, s)
#             for i in range(length+1, n-s+1):
#                 ans += dfs(s+i, s)
            
#             return ans % base
    
        
#         return dfs(0, -1)

# print(Solution().numberOfCombinations("9999999999999"))

class Solution:
    def findDifferentBinaryString(self, nums) -> str:
        n = len(nums)
        answer = set(int(i, 2) for  i in nums)
        base = (1 << n) - 1
        for i in range(1<<n):
            if i not in answer: 
                bin_ =  bin(i)
                return '0'*(n - len(bin_) + 2) + bin_[2:]
        
        

print(Solution().findDifferentBinaryString(["111","011","001"]))

class Solution:
    def minimizeTheDifference(self, mat, target: int) -> int:
        from functools import lru_cache
        m, n = len(mat), len(mat[0])
        self.ans = float('inf')
        for i in mat: i.sort()

        @lru_cache(None)
        def dfs(cur, cum):
            if cur == m:
                self.ans = min(self.ans, abs(cum - target))
                return  
            if cum >= target and  abs(cum - target) >= self.ans: return 
            for i in range(n):
                dfs(cur+1, cum + mat[cur][i])

        
        dfs(0, 0)
        return self.ans


class Solution:
    # 归并
    def minimizeTheDifference(self, mat, target: int) -> int:
        m, n = len(mat), len(mat[0])
        for i in mat: i.sort()
        import bisect
        def merge(l, r, target):
            mid = (l + r) // 2
            if l == r:
                idx =  bisect.bisect_left(mat, target)
                if idx == n: return [mat[l][idx-1], mat[l][idx-1]]
                elif idx == -1:return [mat[l][idx+1], mat[l][idx+1]]
                return [[mat[l][idx-1], mat[l][idx+1]]]
            
            left_less, left_more = merge(l, mid, target / 2) 

print(Solution().minimizeTheDifference([[24,18,31,34,31,47,47,27,32,44,19,26,15,11,32,39,17,36,28,45,44,45,6,38,47,37,7,5,23,12,35,10,27,5,6,44,42,3,9],[19,25,15,46,43,44,22,29,12,34,19,8,10,35,49,28,7,22,34,16,46,33,17,11,11,30,46,16,26,23,49,37,47,10,30,29,47,2,39],[25,48,12,26,33,4,31,18,26,17,46,47,27,46,42,31,24,36,22,46,48,43,6,49,47,15,35,40,13,26,43,25,41,1,21,30,34,46,30],[42,12,7,2,26,14,47,37,39,25,14,7,25,36,50,13,18,48,38,38,13,32,40,9,1,40,44,28,31,17,33,37,12,30,46,14,49,5,23],[1,32,35,43,43,5,49,38,32,44,22,30,18,33,30,2,6,40,49,23,12,49,49,26,17,44,41,47,9,4,11,32,25,30,44,19,10,1,19],[36,30,1,24,3,35,25,37,29,14,44,20,32,42,9,31,45,35,46,20,5,17,21,20,22,42,20,42,42,26,34,6,33,41,14,26,39,34,10],[33,41,6,20,3,15,30,36,15,34,18,4,8,8,44,25,24,14,21,23,5,22,30,24,11,32,29,19,30,9,46,29,41,14,18,21,11,7,16],[31,13,49,44,24,12,23,9,9,15,18,36,41,25,26,48,22,18,47,39,33,38,45,47,21,48,26,49,46,46,41,49,46,19,35,40,41,43,5],[24,20,26,31,12,17,23,29,31,6,12,21,25,9,2,7,23,11,23,5,47,49,42,28,1,35,21,16,39,25,35,19,31,41,10,24,21,13,32],[7,10,14,22,17,10,27,24,17,6,22,13,16,46,16,47,40,3,22,24,42,50,40,4,10,12,5,28,29,50,18,9,21,34,37,8,22,42,50],[46,40,26,15,4,26,50,31,32,40,21,35,40,39,6,38,33,35,43,32,26,45,30,11,27,25,34,29,3,7,29,38,9,8,44,33,12,5,26],[20,30,46,1,17,7,43,23,15,12,2,10,28,43,6,22,42,30,4,31,16,5,31,9,36,2,9,45,33,35,4,4,13,35,1,34,22,44,34],[16,9,24,32,1,9,35,8,16,7,30,14,4,40,14,41,25,22,40,42,26,46,34,33,50,44,11,33,7,10,41,14,12,25,13,20,22,28,10],[28,9,26,21,20,7,36,7,31,18,19,34,49,32,18,15,27,45,9,45,36,43,7,2,39,36,49,13,14,13,26,38,3,42,9,41,2,48,17],[45,47,31,35,4,48,50,15,10,39,21,3,45,13,7,9,41,45,35,12,49,6,44,30,41,19,14,11,21,45,18,34,37,5,27,27,43,47,3],[30,20,43,8,41,45,47,18,2,14,27,22,17,35,47,26,38,34,48,13,28,50,9,45,11,29,30,23,25,31,40,17,40,13,38,31,29,13,49],[31,37,22,20,5,11,24,39,41,31,15,50,40,42,43,37,9,44,20,14,35,20,7,1,2,13,21,4,21,35,17,47,43,22,29,5,27,31,46],[2,19,38,37,9,14,10,11,39,50,25,47,5,41,38,29,18,42,6,32,31,16,10,37,20,15,13,40,46,22,38,40,45,26,34,27,16,42,14],[36,4,17,43,16,9,40,47,26,28,8,30,26,26,31,25,19,14,16,15,4,35,34,6,39,35,44,1,4,25,46,28,26,15,33,18,7,24,33],[24,34,32,38,5,46,30,48,45,15,18,2,2,31,3,9,42,10,14,21,16,35,4,40,10,42,19,49,7,42,36,35,6,44,43,9,28,46,9],[3,20,33,43,18,31,4,36,23,49,22,44,7,39,24,7,39,23,24,41,18,31,19,33,39,10,2,3,22,28,41,1,23,44,35,46,4,43,5],[45,35,33,40,50,28,28,27,16,12,11,40,3,2,38,49,47,23,44,12,19,2,3,16,37,15,26,5,24,8,39,5,16,15,36,13,7,1,45],[26,6,33,18,38,42,15,4,34,34,34,26,28,9,10,28,9,30,48,24,4,37,12,34,29,28,39,42,29,11,32,39,9,23,10,2,17,46,12],[10,41,27,37,41,17,29,31,30,13,28,28,18,50,15,23,49,41,3,26,40,2,28,20,2,36,31,37,17,44,18,16,30,46,30,24,34,40,30],[43,16,36,35,11,30,19,49,24,27,8,33,44,16,48,42,43,25,8,28,39,30,40,34,30,6,48,25,29,40,50,46,45,48,24,36,23,11,10],[15,43,42,12,27,29,32,46,47,12,27,17,21,37,26,20,42,46,17,43,21,43,1,26,38,3,14,30,7,8,1,24,21,39,21,47,26,12,48],[21,6,34,39,31,26,40,16,29,7,39,2,23,2,20,32,9,46,46,4,1,22,26,31,42,40,1,31,41,37,14,15,48,40,21,11,22,20,50],[26,37,39,47,32,30,49,18,6,33,14,37,24,16,24,24,12,16,35,42,47,40,15,14,38,30,16,26,18,38,14,33,11,1,26,50,31,48,24],[42,12,44,13,47,45,39,12,32,40,1,47,9,14,46,14,1,40,6,30,50,41,13,48,12,18,26,40,2,1,24,8,20,3,37,24,31,25,8],[5,30,12,10,50,30,42,5,18,10,31,35,5,34,46,19,19,2,36,36,14,5,27,9,12,38,20,30,13,3,45,22,30,4,10,15,40,23,41],[20,45,42,7,13,10,15,2,21,8,18,7,24,50,5,33,46,40,9,23,9,28,47,48,13,20,36,49,2,49,2,22,41,10,47,5,35,49,4],[9,48,32,27,44,23,31,43,19,20,5,41,10,48,8,1,6,10,23,46,10,20,50,37,44,35,9,6,15,37,47,50,48,15,22,6,12,43,28]]
,145))

class Solution:
    def recoverArray(self, n: int, sums):
        import bisect
        sums.sort()  # 排序
        ans = [0]*len(sums)
        idx = 0
    
        if sums[0] < 0: # 有负数的情况
            idx = bisect.bisect_right(sums, 0)
            print(idx)
            ans[0] = sums[idx-1] 
            for i in range(idx-1, 0, -1):
                ans[idx - i] = sums[i-1] - sums[i]
        
        ans[idx] = sums[idx]
        for i in range(idx+1, n):
            ans[idx] = sums(i) -  sums[i-1]
        
        return  ans


print(Solution().recoverArray(
3,
[-3,-2,-1,0,0,1,2,3]
))


Traceback (most recent call last):
  File "Solution.py", line 1, in <module>
    k = int(input())
EOFError: EOF when reading a line

Traceback (most recent call last):
  File "Solution.py", line 5, in <module>
    names = input().split('\n')[1:]
EOFError: EOF when reading a line
Traceback (most recent call last):
  File "Solution.py", line 7, in <module>
    if names.isidentifier() and any(str(i) in name for i in range(10)):
AttributeError: 'list' object has no attribute 'isidentifier'
